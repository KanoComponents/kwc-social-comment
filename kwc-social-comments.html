<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../iron-autogrow-textarea/iron-autogrow-textarea.html">
<link rel="import" href="../iron-image/iron-image.html">
<link rel="import" href="../iron-icons/iron-icons.html">
<link rel="import" href="../kwc-icons/kwc-social-icons.html">
<link rel="import" href="../kwc-button/kwc-button.html">
<link rel="import" href="../kwc-style/kwc-style.html">

<!--
`<kwc-social-comments>`

Comment feed for use in social media flavoured components. Add this component somewhere in your html body, or more likely embed it into another comonent.

```html
    <body>
      <kwc-social-comments></kwc-social-comments>
```
The component does not make any assumptions on how you are handling comment loading, or how they are stored by the api. Control of `loading` and `posting` states are done through attributes that can be set by any wrapper component.

This component expects a list of comment objects of the following form:
```json
{
    "type": "object",
    "properties": {
        "id": {
            "type": "string"
        },
        "author": {
            "type": "object",
            "properties": {
                "id": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                },
                "avatar": {
                    "type": "string"
                },
            }
        },
        "text": {
            "type": "string"
        },
        "createdOn": {
            "type": "string"
        },
        "flags": {
            "type": "array",
            "items": {}
        },
    },
    "required" : ["id", "text", "createdOn"]
}
```

## State attributes
### Loading
This commponent can be put into a `loading` state by setting the `loaderState` property or `loader-state` attribute to `"disabled"`. This will disable the "load more" button until the state is reset to `"on"`.

If there are no more comments to load, the "load more" button can be hidden by setting the loader state to `"off"`.

### Posting
The comment input can be disabled by setting the `posting` attribute or property on the element to `true`. This can be used to prevent a user from posting a second comment whilst the first is still being sent, if this is a desired behaviour.

@demo demo/index.html
-->

<dom-module id="kwc-social-comments">
    <template>
        <style>
            :host {
                @apply --layout-vertical;
                @apply --layout-center;
                @apply --layout-justified;
                width: 100%;
            }
            :host([tombstone]) * {
                visibility: hidden;
            }
            :host([hidden]) {
                display: none !important;
            }
            .input-comment {
                @apply --layout-horizontal;
                border-bottom: 1px solid var(--color-porcelain);
                padding: 24px 0;
                margin: 0;
                width: 100%;
            }
            .comment-avatar {
                border-radius: 50%;
                flex: none;
                height: 40px;
                margin: 0 24px;
                overflow: hidden;
                position: relative;
                width: 40px;
            }
            .avatar {
                height: 40px;
                width: 40px;
                cursor: pointer;
            }
            .comment .avatar {
                cursor: pointer;
            }
            iron-image {
                height: 32px;
                width: 32px;
                border-radius: 50%;
            }
            .comment-form {
                @apply --layout-flex-2;
            }
            .comment-box {
                border: 1px solid var(--color-porcelain);
                border-radius: 3px;
                box-sizing: border-box;
                font-family: var(--font-body);
                font-size: 16px;
                line-height: 20px;
                padding: 8px 16px 8px 16px;
                width: 100%;
            }
            .comment-box:focus {
                border-color: var(--color-azure);
                outline: 0;
            }
            .comment {
                @apply --layout-horizontal;
                @apply --layout-start;
                border-bottom: 1px solid var(--color-porcelain);
                padding: 24px 0;
                width: 100%;
            }
            .comment.posting {
                opacity: 0.6;
            }
            .content {
                @apply --layout-flex-2;
                font-size: 16px;
                font-family: var(--font-body);
                color: var(--color-abbey);
                max-width: 450px;
            }
            .comment-header {
                margin: 0;
            }
            .content p {
                margin: 0;
                width: 100%;
            }
            .content .date {
                font-size: 14px;
                font-family: var(--font-body);
                color: var(--color-grey);
            }
            p {
                font-family: var(--font-body);
                color: var(--color-chateau);
                font-size: 16px;
                line-height: 20px;
                word-wrap: break-word;
            }
            .comment-body {
                color: var(--color-black);
            }
            .comment:hover .action.delete,
            .comment:hover .action.flag {
                visibility: visible;
            }
            .author {
                color: var(--color-kano-orange);
                cursor: pointer;
                font-weight: bold;
                margin-right: 5px;
            }
            .actions {
                @apply --layout-end;
                @apply --layout-vertical;
                flex: none;
                width: calc(15% - 40px);
            }
            .control-actions {
                @apply --layout-horizontal;
                @apply --layout-center;
                @apply --layout-end-justified;
            }
            .action:focus {
                outline: 0;
            }
            .action.delete,
            .action.flag {
                -webkit-appearance: none;
                background: transparent;
                border: 0;
                border-radius: 3px;
                color: var(--color-grey);
                cursor: pointer;
                visibility: hidden;
            }
            .action.flag:hover {
                color: var(--color-carnation);
            }
            .action.flag.flagged {
                color: var(--color-carnation);
                cursor: default;
                visibility: visible;
            }
            .action.flag .icon {
                height: 16px;
                width: 16px;
            }
            #retry {
                margin-top: 10px;
                line-height: 15px;
                height:25px;
            }
            iron-list {
                width: 100%;
                height: 100%
            }
            .loader {
                margin-top: 20px;
            }
            .loader[hidden] {
                display: block;
            }
            :host([loader-status="off"]) #loader {
                display: none;
            }
            :host([loader-status="disabled"]) #loader {
                background-color: var(--color-porcelain);
                color: rgba(41, 47, 53, 1);
            }
            kwc-button[hidden] {
                display: none;
            }
            :host([retry-button="hide"]) #retry {
                display: none;
            }
        </style>
        <div class="input-comment">
            <div class="comment-avatar">
                <iron-image class="avatar"
                            src$="[[_avatar]]"
                            sizing="cover"
                            preload fade>
                            </iron-image>
            </div>
            <form class="comment-form" on-submit="_submitComment">
                <input class="comment-box"
                       type="text"
                       placeholder$="[[_placeholderText]]"
                       value="{{_comment::input}}"
                       disabled$="[[posting]]"/>
            </form>
        </div>
        <template is="dom-repeat" items="[[comments]]" as="comment">
            <div id$="[[comment.id]]" class$="comment [[_computePostingClass(comment)]]">
                <div class="comment-avatar">
                    <iron-image class="avatar"
                                src$="[[_computeAvatar(comment.author)]]"
                                sizing="cover"
                                preload fade
                                on-tap="_userTapped">
                                </iron-image>
                </div>
                <div class="content">
                    <p class="comment-header">
                        <span class="author"
                              on-tap="_userTapped">
                            {{comment.author.username}}
                        </span>
                        <span class="date">
                            [[_timeSince(comment.date_created, comments.*)]] ago
                        </span>
                    </p>
                    <p class="comment-body">
                        <span inner-h-t-m-l="[[_lb(comment.text)]]"></span>
                    </p>
                </div>
                <div class="actions">
                    <div class="control-actions">
                        <template is="dom-if" if="[[_commentIsDeletable(comment.author.id, user.id, user.admin_level)]]">
                            <button type="button"
                                    class="action delete"
                                    on-tap="_deleteButtonTapped">
                                <iron-icon class="icon" icon="kwc-ui-icons:rubbish-bin"></iron-icon>
                            </button>
                        </template>
                        <button type="button"
                                class$="[[_computeFlagClass(comment.flags.*)]]"
                                on-tap="_flagButtonTapped">
                            <iron-icon class="icon" icon="kwc-social-icons:flag"></iron-icon>
                        </button>
                    </div>
                    <kwc-button id="retry"
                            on-tap="_retryButtonTapped"
                            hidden$="[[!comment.error]]"
                            type="warning"
                            transparent>
                        retry
                    </kwc-button>
                </div>
            </div>
        </template>
        <kwc-button class="loader"
                    id="loader"
                    type="secondary"
                    on-tap="_loadMoreData">
            Load more
        </kwc-button>
    </template>
    <script>
        Polymer({
            is: 'kwc-social-comments',
            properties: {
                /**
                 * Computer value for avatar
                 * @type {String}
                 */
                _avatar: {
                    type: String,
                    computed: '_computeAvatar(user)'
                },
                /**
                 * Current value for comment input
                 * @type {String}
                 */
                _comment: {
                    type: String
                },
                 /**
                 * Array of comment objects to render
                 * @type {Array}
                 */
                comments: {
                    type: Array,
                    value: () => {
                        return [];
                    },
                    notify: true
                },
                /**
                 * Default Avatar to use when not provided by comment or user data
                 * @type {String}
                 */
                defaultAvatar: {
                    type: String,
                    value: 'https://s3.amazonaws.com/kano-avatars/default-avatar.svg'
                },
                /**
                 * An identifier to this comment thread, to be used in the `post-comment` event.
                 * @type {String}
                 */
                itemId: {
                    type: String
                },
                /**
                 * Value of next page of comments if using pagination.
                 * @type {Number}
                 */
                nextPage: {
                    type: Number,
                    value: 0,
                    observer: '_onDataLoad'
                },
                /**
                 * Text to use as placeholder. Computed on whether we have comments or not.
                 * @type {String}
                 */
                _placeholderText: {
                    type: String,
                    computed: '_computePlaceholderText(comments)'
                },
                /**
                 * Atribute to indicate a comment is being posted. Will disable input.
                 * @type {Boolean}
                 */
                posting: {
                    type: Boolean,
                    value: false
                },
                /**
                 * Atribute to loader status of the component.
                 * Can be one of `on|off|disabled`. Will disable (disabled) or hide (off) load button.
                 * @type {String}
                 */
                loaderStatus: {
                    type: String,
                    value: "off",
                    reflectToAttribute: true
                },
                /**
                 * Atribute used to hide the retry button once clicked.
                 * @type {Boolean}
                 */
                retryButton: {
                    type: String,
                    reflectToAttribute: true
                },
                /**
                 * Current authenticated user.
                 * @type {String}
                 */
                user: {
                    type: Object,
                    value: () => {
                        return {};
                    }
                }
            },
            _computeAvatar(user) {
                if (user) {
                    return user.avatar || this.defaultAvatar;
                }
                return this.defaultAvatar;
            },
            _onDataLoad() {
                this.$.loader.disabled = false;
            },
            _loadMoreData() {
                if (!this.itemId || this.$.loader.disabled) {
                    return;
                }
                this.$.loader.disabled = true;
                this.dispatchEvent(new CustomEvent('load-comment', {
                    detail: {
                        id: this.itemId
                    }
                }));
            },
            _createDate(formatted) {
                return new Date(formatted);
            },
            /**
             * Compute whether a comment is deletable by the current user
             * â€“ either they must have written the comment, or they must be
             * a Kano admin.
             * @param {String} commentAuthorId
             * @param {String} userId
             * @param {Number} userAdminLevel
             * @returns {Boolean}
             */
            _commentIsDeletable(commentAuthorId, userId, userAdminLevel) {
                  return commentAuthorId === userId || userAdminLevel > 0;
            },
            _computeFlag(flags) {
                if (!flags || !this.user) {
                    return false;
                }
                return flags.some(flag => {
                    return flag.author === this.user.id;
                });
            },
            _computeFlagClass(splice) {
                let baseClass = 'action flag',
                    activeClass = this._computeFlag(splice.base) ? 'flagged' : 'unflagged';
                return `${baseClass} ${activeClass}`;
            },
            _computePlaceholderText(comments) {
                if (!comments || !comments.length) {
                    return 'Be the first to comment';
                }
                return 'Leave a comment';
            },
            _computePostingClass(comment) {
                return `${comment.posting ? 'posting' : ''}${comment.error ? 'error' : ''}`;
            },
            _computeErrorClass(error) {
                return error ? 'error' : '';
            },
            _computeErrorState(error) {
                return error ? true : '';
            },
            /**
             * Dispatch the event to delete a comment
             * @param {Event} e
             */
            _deleteButtonTapped(e) {
                this.dispatchEvent(new CustomEvent('delete-comment', {
                    detail: {
                        index: e.model.index,
                        id: e.model.comment.id
                    }
                }));
            },
            _isHintHidden(e) {
                return true;
            },
            _lb(value) {
                let safeDiv = document.createElement('div');
                safeDiv.textContent = value;
                return safeDiv.innerHTML.replace(/\n/g, '<br>');
            },
            /**
            * Fired when flag icon is pressed on an individual comment.
            *
            * @event flag-comment
            * @param {string} index Index in comments array.
            * @param {string} id Id of comment as given by comment object.
            */
            _flagButtonTapped(e) {
                let index = e.model.index,
                    id = this.comments[index].id,
                    flaged = this._computeFlag(this.comments[index].flags);
                if (flaged) {
                    return;
                }
                this.dispatchEvent(new CustomEvent('flag-comment', {
                    detail: {
                        index,
                        id
                    }
                }));
            },
            /**
            * Fired when retry is clicked on an individual comment that has errored.
            *
            * @event post-comment
            * @param {string} value Comment text.
            * @param {boolean} retry Flag to indicate the post is a retry.
            */
            _retryButtonTapped() {
                this.set('retryButton', 'hide');
                this.dispatchEvent(new CustomEvent('post-comment', {
                    detail: {
                        value: this.comments[0].text,
                        retry: true
                    }
                }));
            },
            /**
            * Fired when new comment is submited.
            *
            * @event post-comment
            * @param {string} value Comment text.
            */
            _submitComment(e) {
                e.preventDefault();
                this.dispatchEvent(new CustomEvent('post-comment', {
                    detail: {
                        value: this._comment
                    }
                }));
                this._comment = '';
            },
            _timeSince(date) {
                let parsedDate = new Date(date),
                    seconds = Math.floor((new Date() - parsedDate) / 1000),
                    interval = Math.floor(seconds / 31536000);
                if (interval > 1) {
                    return interval + ' years';
                }
                interval = Math.floor(seconds / 2592000);
                if (interval > 1) {
                    return interval + ' months';
                }
                interval = Math.floor(seconds / 86400);
                if (interval > 1) {
                    return interval + ' days';
                }
                interval = Math.floor(seconds / 3600);
                if (interval > 1) {
                    return interval + ' hours';
                }
                interval = Math.floor(seconds / 60);
                if (interval > 1) {
                    return interval + ' minutes';
                }
                return Math.floor(seconds) + ' seconds';
            },
            /**
            * Fired when the user icon or name is tapped on an individual comment.
            *
            * @event view-user
            * @param {string} id provided by the `comment.author.id` property.
            */
            _userTapped(e) {
                let index = e.model.index,
                    author = this.comments[index].author;
                if (author) {
                    this.dispatchEvent(new CustomEvent('view-user', {
                        detail: {
                            id: author.id,
                            username: author.username
                        }
                    }));
                }
            }
        });
    </script>
</dom-module>
